---
description:
globs:
alwaysApply: false
---
# 6ë‹¨ê³„: ìŠ¤íŠ¸ë¦¬ë° API ì™„ì„±

## ğŸ¯ ëª©í‘œ
ì‹¤ì‹œê°„ í†µì‹  ì‹œìŠ¤í…œ ì™„ì„± - Server-Sent Events êµ¬í˜„, ì‹¤ì‹œê°„ ê²€ìƒ‰ ì§„í–‰ ìƒí™© ì „ì†¡, ì—ëŸ¬ ìŠ¤íŠ¸ë¦¬ë°, ì„¸ì…˜ ê´€ë¦¬

## ğŸ“‹ ìƒì„¸ íƒœìŠ¤í¬

### 6.1 ê³ ê¸‰ ìŠ¤íŠ¸ë¦¬ë° ì„œë¹„ìŠ¤ êµ¬í˜„

#### í–¥ìƒëœ ìŠ¤íŠ¸ë¦¬ë° ì„œë¹„ìŠ¤ (`src/api/services/streaming.py` ì—…ë°ì´íŠ¸)
```python
import asyncio
import json
import uuid
from typing import AsyncGenerator, Dict, Any, Optional, List
from datetime import datetime
import logging

from ..models.chat import StreamEvent
from ...agent.core import PriceFinderAgent

logger = logging.getLogger(__name__)

class StreamingService:
    """ê³ ê¸‰ ìŠ¤íŠ¸ë¦¬ë° ì„œë¹„ìŠ¤ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.agent = PriceFinderAgent()
        self.active_sessions = {}  # í™œì„± ì„¸ì…˜ ê´€ë¦¬
    
    @staticmethod
    async def create_sse_response(event: StreamEvent) -> str:
        """Server-Sent Events í˜•ì‹ìœ¼ë¡œ ì‘ë‹µ ìƒì„±"""
        data = {
            "type": event.type,
            "data": event.data,
            "timestamp": event.timestamp.isoformat(),
            "session_id": event.session_id
        }
        return f"data: {json.dumps(data, ensure_ascii=False)}\n\n"
    
    async def stream_chat_response(
        self, 
        message: str, 
        session_id: str
    ) -> AsyncGenerator[str, None]:
        """Agentë¥¼ ì‚¬ìš©í•œ ì±„íŒ… ì‘ë‹µ ìŠ¤íŠ¸ë¦¬ë°"""
        
        # ì„¸ì…˜ ë“±ë¡
        self.active_sessions[session_id] = {
            "start_time": datetime.now(),
            "message": message,
            "status": "processing"
        }
        
        try:
            # ì‹œì‘ ì´ë²¤íŠ¸
            yield await self._send_event("start", {
                "message": "ğŸ” AI Agentê°€ ìš”ì²­ì„ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...",
                "session_id": session_id
            }, session_id)
            
            # ë©”ì‹œì§€ ë¶„ì„ ë‹¨ê³„
            yield await self._send_event("analysis", {
                "message": f"'{message}' ìš”ì²­ì„ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...",
                "step": "message_analysis"
            }, session_id)
            
            await asyncio.sleep(0.5)  # ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜
            
            # ê²€ìƒ‰ ì‹œì‘ ë‹¨ê³„
            yield await self._send_event("search_start", {
                "message": "ğŸ›’ ì—¬ëŸ¬ ì‡¼í•‘ëª°ì—ì„œ ìƒí’ˆì„ ê²€ìƒ‰í•˜ê³  ìˆìŠµë‹ˆë‹¤...",
                "step": "product_search",
                "shops": ["ì¿ íŒ¡", "11ë²ˆê°€", "Gë§ˆì¼“", "ì˜¥ì…˜", "ë„¤ì´ë²„ì‡¼í•‘"]
            }, session_id)
            
            # Agent ì‹¤í–‰
            result = await self.agent.process_message(message, session_id)
            
            if result["success"]:
                # ê²€ìƒ‰ ê²°ê³¼ ì²˜ë¦¬
                agent_result = result["result"]
                
                # ê²€ìƒ‰ ê²°ê³¼ê°€ ìˆëŠ” ê²½ìš°
                if hasattr(agent_result, 'search_results') and agent_result.search_results:
                    yield await self._send_event("search_results", {
                        "message": f"âœ… {len(agent_result.search_results)}ê°œ ìƒí’ˆì„ ì°¾ì•˜ìŠµë‹ˆë‹¤!",
                        "products": agent_result.search_results,
                        "step": "results_found"
                    }, session_id)
                    
                    # ê°€ê²© ë¹„êµ ë‹¨ê³„
                    yield await self._send_event("price_comparison", {
                        "message": "ğŸ’° ê°€ê²©ì„ ë¹„êµí•˜ê³  ìµœì ì˜ ì˜µì…˜ì„ ì°¾ê³  ìˆìŠµë‹ˆë‹¤...",
                        "step": "price_analysis"
                    }, session_id)
                    
                    await asyncio.sleep(0.5)  # ë¹„êµ ì‹œë®¬ë ˆì´ì…˜
                    
                    # ìµœì¢… ì¶”ì²œ
                    best_deal = self._find_best_deal(agent_result.search_results)
                    yield await self._send_event("recommendation", {
                        "message": "ğŸ† ìµœì ì˜ ìƒí’ˆì„ ì°¾ì•˜ìŠµë‹ˆë‹¤!",
                        "best_deal": best_deal,
                        "step": "recommendation"
                    }, session_id)
                
                # Agent ìµœì¢… ì‘ë‹µ
                final_message = self._generate_final_message(agent_result)
                yield await self._send_event("agent_response", {
                    "message": final_message,
                    "agent_result": agent_result,
                    "tools_used": result.get("tools_used", [])
                }, session_id)
                
            else:
                # ì—ëŸ¬ ì²˜ë¦¬
                yield await self._send_event("error", {
                    "message": "ì£„ì†¡í•©ë‹ˆë‹¤. ê²€ìƒ‰ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
                    "error": result["error"],
                    "error_type": "agent_error"
                }, session_id)
        
        except Exception as e:
            logger.error(f"ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            yield await self._send_event("error", {
                "message": "ì‹œìŠ¤í…œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.",
                "error": str(e),
                "error_type": "system_error"
            }, session_id)
        
        finally:
            # ì™„ë£Œ ì´ë²¤íŠ¸
            yield await self._send_event("complete", {
                "message": "ê²€ìƒ‰ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
                "session_id": session_id,
                "duration": self._calculate_duration(session_id)
            }, session_id)
            
            # ì„¸ì…˜ ì •ë¦¬
            self._cleanup_session(session_id)
    
    async def stream_image_response(
        self,
        image_data: bytes,
        message: str,
        session_id: str
    ) -> AsyncGenerator[str, None]:
        """ì´ë¯¸ì§€ ê²€ìƒ‰ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ"""
        
        try:
            # ì´ë¯¸ì§€ ë¶„ì„ ì‹œì‘
            yield await self._send_event("image_analysis_start", {
                "message": "ğŸ“¸ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...",
                "step": "image_processing"
            }, session_id)
            
            await asyncio.sleep(1)  # ì´ë¯¸ì§€ ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜
            
            # ìƒí’ˆ ì‹ë³„
            yield await self._send_event("product_identification", {
                "message": "ğŸ” ì´ë¯¸ì§€ì—ì„œ ìƒí’ˆì„ ì‹ë³„í•˜ê³  ìˆìŠµë‹ˆë‹¤...",
                "step": "product_recognition"
            }, session_id)
            
            # TODO: 7ë‹¨ê³„ì—ì„œ ì‹¤ì œ ì´ë¯¸ì§€ ë¶„ì„ êµ¬í˜„
            # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ ì‘ë‹µ
            yield await self._send_event("image_result", {
                "message": "ì´ë¯¸ì§€ ê²€ìƒ‰ ê¸°ëŠ¥ì€ 7ë‹¨ê³„ì—ì„œ êµ¬í˜„ë©ë‹ˆë‹¤.",
                "identified_product": "ìƒí’ˆ ì‹ë³„ ì˜ˆì •",
                "confidence": 0.0
            }, session_id)
            
        except Exception as e:
            yield await self._send_event("error", {
                "message": "ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
                "error": str(e),
                "error_type": "image_processing_error"
            }, session_id)
        
        finally:
            yield await self._send_event("complete", {
                "message": "ì´ë¯¸ì§€ ê²€ìƒ‰ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
                "session_id": session_id
            }, session_id)
    
    async def _send_event(self, event_type: str, data: Dict[str, Any], session_id: str) -> str:
        """ì´ë²¤íŠ¸ ì „ì†¡ í—¬í¼"""
        event = StreamEvent(
            type=event_type,
            data=data,
            session_id=session_id,
            timestamp=datetime.now()
        )
        return await self.create_sse_response(event)
    
    def _find_best_deal(self, products: List[Dict[str, Any]]) -> Dict[str, Any]:
        """ìµœì  ìƒí’ˆ ì°¾ê¸°"""
        if not products:
            return {}
        
        # ì´ ê°€ê²© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
        sorted_products = sorted(
            products, 
            key=lambda x: x.get('price', float('inf')) + x.get('shipping_fee', 0)
        )
        
        best_product = sorted_products[0]
        total_price = best_product.get('price', 0) + best_product.get('shipping_fee', 0)
        
        return {
            "product": best_product,
            "total_price": total_price,
            "savings": self._calculate_savings(products, best_product),
            "reasons": self._get_recommendation_reasons(best_product)
        }
    
    def _calculate_savings(self, products: List[Dict[str, Any]], best_product: Dict[str, Any]) -> int:
        """ì ˆì•½ ê¸ˆì•¡ ê³„ì‚°"""
        if len(products) < 2:
            return 0
        
        prices = [p.get('price', 0) + p.get('shipping_fee', 0) for p in products]
        best_price = best_product.get('price', 0) + best_product.get('shipping_fee', 0)
        
        return max(prices) - best_price
    
    def _get_recommendation_reasons(self, product: Dict[str, Any]) -> List[str]:
        """ì¶”ì²œ ì´ìœ  ìƒì„±"""
        reasons = ["ìµœì €ê°€ ìƒí’ˆ"]
        
        if product.get('shipping_fee', 0) == 0:
            reasons.append("ë¬´ë£Œë°°ì†¡")
        
        if product.get('rating', 0) >= 4.0:
            reasons.append(f"ë†’ì€ í‰ì  ({product.get('rating', 0):.1f}ì )")
        
        if product.get('discount_rate', 0) > 10:
            reasons.append(f"ë†’ì€ í• ì¸ìœ¨ ({product.get('discount_rate', 0):.1f}%)")
        
        return reasons
    
    def _generate_final_message(self, agent_result) -> str:
        """ìµœì¢… ë©”ì‹œì§€ ìƒì„±"""
        if hasattr(agent_result, 'search_results') and agent_result.search_results:
            product_count = len(agent_result.search_results)
            return f"ğŸ‰ ì´ {product_count}ê°œ ìƒí’ˆì„ ì°¾ì•„ ê°€ê²©ì„ ë¹„êµí–ˆìŠµë‹ˆë‹¤. ìµœì ì˜ ì˜µì…˜ì„ í™•ì¸í•´ë³´ì„¸ìš”!"
        else:
            return "ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤. ì¶”ê°€ ë„ì›€ì´ í•„ìš”í•˜ì‹œë©´ ë§ì”€í•´ ì£¼ì„¸ìš”."
    
    def _calculate_duration(self, session_id: str) -> float:
        """ì„¸ì…˜ ì§€ì† ì‹œê°„ ê³„ì‚°"""
        if session_id in self.active_sessions:
            start_time = self.active_sessions[session_id]["start_time"]
            return (datetime.now() - start_time).total_seconds()
        return 0.0
    
    def _cleanup_session(self, session_id: str):
        """ì„¸ì…˜ ì •ë¦¬"""
        if session_id in self.active_sessions:
            del self.active_sessions[session_id]
    
    async def get_session_status(self, session_id: str) -> Dict[str, Any]:
        """ì„¸ì…˜ ìƒíƒœ ì¡°íšŒ"""
        if session_id in self.active_sessions:
            session = self.active_sessions[session_id]
            return {
                "active": True,
                "start_time": session["start_time"].isoformat(),
                "message": session["message"],
                "status": session["status"],
                "duration": self._calculate_duration(session_id)
            }
        return {"active": False}
```

### 6.2 ì„¸ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### ì„¸ì…˜ ê´€ë¦¬ì (`src/api/services/session_manager.py`)
```python
import uuid
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
import asyncio
import logging

logger = logging.getLogger(__name__)

class SessionManager:
    """ì„¸ì…˜ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.sessions: Dict[str, Dict[str, Any]] = {}
        self.session_timeout = 3600  # 1ì‹œê°„
        self._cleanup_task = None
        self._start_cleanup_task()
    
    def create_session(self) -> str:
        """ìƒˆ ì„¸ì…˜ ìƒì„±"""
        session_id = str(uuid.uuid4())
        self.sessions[session_id] = {
            "id": session_id,
            "created_at": datetime.now(),
            "last_activity": datetime.now(),
            "message_count": 0,
            "search_history": [],
            "current_products": [],
            "user_preferences": {},
            "status": "active"
        }
        
        logger.info(f"ìƒˆ ì„¸ì…˜ ìƒì„±: {session_id}")
        return session_id
    
    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """ì„¸ì…˜ ì •ë³´ ì¡°íšŒ"""
        if session_id in self.sessions:
            session = self.sessions[session_id]
            # ë§ˆì§€ë§‰ í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸
            session["last_activity"] = datetime.now()
            return session
        return None
    
    def update_session(self, session_id: str, updates: Dict[str, Any]) -> bool:
        """ì„¸ì…˜ ì •ë³´ ì—…ë°ì´íŠ¸"""
        if session_id in self.sessions:
            self.sessions[session_id].update(updates)
            self.sessions[session_id]["last_activity"] = datetime.now()
            return True
        return False
    
    def add_message_to_session(self, session_id: str, message: Dict[str, Any]) -> bool:
        """ì„¸ì…˜ì— ë©”ì‹œì§€ ì¶”ê°€"""
        if session_id in self.sessions:
            session = self.sessions[session_id]
            session["message_count"] += 1
            session["last_activity"] = datetime.now()
            
            # ê²€ìƒ‰ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
            if message.get("role") == "user":
                session["search_history"].append({
                    "query": message.get("content", ""),
                    "timestamp": datetime.now()
                })
            
            return True
        return False
    
    def add_products_to_session(self, session_id: str, products: List[Dict[str, Any]]) -> bool:
        """ì„¸ì…˜ì— ìƒí’ˆ ì •ë³´ ì¶”ê°€"""
        if session_id in self.sessions:
            self.sessions[session_id]["current_products"] = products
            self.sessions[session_id]["last_activity"] = datetime.now()
            return True
        return False
    
    def get_session_history(self, session_id: str) -> List[Dict[str, Any]]:
        """ì„¸ì…˜ ê²€ìƒ‰ íˆìŠ¤í† ë¦¬ ì¡°íšŒ"""
        session = self.get_session(session_id)
        if session:
            return session.get("search_history", [])
        return []
    
    def get_session_products(self, session_id: str) -> List[Dict[str, Any]]:
        """ì„¸ì…˜ í˜„ì¬ ìƒí’ˆ ëª©ë¡ ì¡°íšŒ"""
        session = self.get_session(session_id)
        if session:
            return session.get("current_products", [])
        return []
    
    def delete_session(self, session_id: str) -> bool:
        """ì„¸ì…˜ ì‚­ì œ"""
        if session_id in self.sessions:
            del self.sessions[session_id]
            logger.info(f"ì„¸ì…˜ ì‚­ì œ: {session_id}")
            return True
        return False
    
    def get_active_sessions(self) -> List[str]:
        """í™œì„± ì„¸ì…˜ ëª©ë¡ ì¡°íšŒ"""
        return list(self.sessions.keys())
    
    def get_session_stats(self) -> Dict[str, Any]:
        """ì„¸ì…˜ í†µê³„ ì¡°íšŒ"""
        total_sessions = len(self.sessions)
        active_sessions = len([s for s in self.sessions.values() if s["status"] == "active"])
        
        if total_sessions > 0:
            avg_messages = sum(s["message_count"] for s in self.sessions.values()) / total_sessions
        else:
            avg_messages = 0
        
        return {
            "total_sessions": total_sessions,
            "active_sessions": active_sessions,
            "average_messages_per_session": round(avg_messages, 2),
            "oldest_session": min(
                (s["created_at"] for s in self.sessions.values()), 
                default=None
            )
        }
    
    def _start_cleanup_task(self):
        """ì •ë¦¬ ì‘ì—… ì‹œì‘"""
        if self._cleanup_task is None:
            self._cleanup_task = asyncio.create_task(self._periodic_cleanup())
    
    async def _periodic_cleanup(self):
        """ì£¼ê¸°ì  ì„¸ì…˜ ì •ë¦¬"""
        while True:
            try:
                await asyncio.sleep(300)  # 5ë¶„ë§ˆë‹¤ ì‹¤í–‰
                await self._cleanup_expired_sessions()
            except Exception as e:
                logger.error(f"ì„¸ì…˜ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
    
    async def _cleanup_expired_sessions(self):
        """ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬"""
        current_time = datetime.now()
        expired_sessions = []
        
        for session_id, session in self.sessions.items():
            last_activity = session["last_activity"]
            if (current_time - last_activity).total_seconds() > self.session_timeout:
                expired_sessions.append(session_id)
        
        for session_id in expired_sessions:
            self.delete_session(session_id)
            logger.info(f"ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬: {session_id}")
        
        if expired_sessions:
            logger.info(f"ì´ {len(expired_sessions)}ê°œ ë§Œë£Œ ì„¸ì…˜ ì •ë¦¬ ì™„ë£Œ")
```

### 6.3 ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬ ì‹œìŠ¤í…œ

#### ì—ëŸ¬ í•¸ë“¤ëŸ¬ (`src/api/services/error_handler.py`)
```python
import logging
from typing import Dict, Any, Optional
from datetime import datetime
from enum import Enum

logger = logging.getLogger(__name__)

class ErrorType(Enum):
    """ì—ëŸ¬ íƒ€ì… ì •ì˜"""
    AGENT_ERROR = "agent_error"
    NETWORK_ERROR = "network_error"
    TIMEOUT_ERROR = "timeout_error"
    VALIDATION_ERROR = "validation_error"
    SYSTEM_ERROR = "system_error"
    RATE_LIMIT_ERROR = "rate_limit_error"

class ErrorHandler:
    """ì—ëŸ¬ ì²˜ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.error_counts = {}
        self.error_history = []
    
    def handle_error(
        self, 
        error: Exception, 
        context: Dict[str, Any],
        session_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """ì—ëŸ¬ ì²˜ë¦¬ ë° ì‘ë‹µ ìƒì„±"""
        
        error_type = self._classify_error(error)
        error_info = {
            "type": error_type.value,
            "message": str(error),
            "timestamp": datetime.now(),
            "context": context,
            "session_id": session_id
        }
        
        # ì—ëŸ¬ ë¡œê¹…
        self._log_error(error_info)
        
        # ì—ëŸ¬ í†µê³„ ì—…ë°ì´íŠ¸
        self._update_error_stats(error_type)
        
        # ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ ìƒì„±
        user_message = self._generate_user_message(error_type, error)
        
        # ë³µêµ¬ ì œì•ˆ ìƒì„±
        recovery_suggestions = self._generate_recovery_suggestions(error_type)
        
        return {
            "error": True,
            "error_type": error_type.value,
            "user_message": user_message,
            "recovery_suggestions": recovery_suggestions,
            "technical_details": str(error) if context.get("debug", False) else None,
            "timestamp": error_info["timestamp"].isoformat()
        }
    
    def _classify_error(self, error: Exception) -> ErrorType:
        """ì—ëŸ¬ ë¶„ë¥˜"""
        error_str = str(error).lower()
        
        if "timeout" in error_str or "timed out" in error_str:
            return ErrorType.TIMEOUT_ERROR
        elif "network" in error_str or "connection" in error_str:
            return ErrorType.NETWORK_ERROR
        elif "rate limit" in error_str or "too many requests" in error_str:
            return ErrorType.RATE_LIMIT_ERROR
        elif "validation" in error_str or "invalid" in error_str:
            return ErrorType.VALIDATION_ERROR
        elif "agent" in error_str or "llm" in error_str:
            return ErrorType.AGENT_ERROR
        else:
            return ErrorType.SYSTEM_ERROR
    
    def _generate_user_message(self, error_type: ErrorType, error: Exception) -> str:
        """ì‚¬ìš©ì ì¹œí™”ì  ì—ëŸ¬ ë©”ì‹œì§€ ìƒì„±"""
        messages = {
            ErrorType.AGENT_ERROR: "AI ì²˜ë¦¬ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì§ˆë¬¸í•´ ë³´ì‹œê±°ë‚˜ ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.",
            ErrorType.NETWORK_ERROR: "ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.",
            ErrorType.TIMEOUT_ERROR: "ìš”ì²­ ì²˜ë¦¬ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.",
            ErrorType.VALIDATION_ERROR: "ì…ë ¥ ì •ë³´ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ë‹¤ì‹œ ì…ë ¥í•´ ì£¼ì„¸ìš”.",
            ErrorType.RATE_LIMIT_ERROR: "ë„ˆë¬´ ë§ì€ ìš”ì²­ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.",
            ErrorType.SYSTEM_ERROR: "ì‹œìŠ¤í…œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
        }
        
        return messages.get(error_type, "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
    
    def _generate_recovery_suggestions(self, error_type: ErrorType) -> List[str]:
        """ë³µêµ¬ ì œì•ˆ ìƒì„±"""
        suggestions = {
            ErrorType.AGENT_ERROR: [
                "ë” êµ¬ì²´ì ì¸ ìƒí’ˆëª…ìœ¼ë¡œ ë‹¤ì‹œ ê²€ìƒ‰í•´ ë³´ì„¸ìš”",
                "ë¸Œëœë“œëª…ê³¼ ëª¨ë¸ëª…ì„ í¬í•¨í•´ì„œ ê²€ìƒ‰í•´ ë³´ì„¸ìš”",
                "ë‹¤ë¥¸ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰í•´ ë³´ì„¸ìš”"
            ],
            ErrorType.NETWORK_ERROR: [
                "ì¸í„°ë„· ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”",
                "ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”",
                "í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ ë³´ì„¸ìš”"
            ],
            ErrorType.TIMEOUT_ERROR: [
                "ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”",
                "ë” ê°„ë‹¨í•œ ê²€ìƒ‰ì–´ë¡œ ì‹œë„í•´ ë³´ì„¸ìš”"
            ],
            ErrorType.VALIDATION_ERROR: [
                "ì˜¬ë°”ë¥¸ ìƒí’ˆëª…ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”",
                "íŠ¹ìˆ˜ë¬¸ìë¥¼ ì œê±°í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ ë³´ì„¸ìš”"
            ],
            ErrorType.RATE_LIMIT_ERROR: [
                "1-2ë¶„ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”",
                "ë„ˆë¬´ ë¹ ë¥¸ ì—°ì† ìš”ì²­ì„ í”¼í•´ ì£¼ì„¸ìš”"
            ],
            ErrorType.SYSTEM_ERROR: [
                "ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”",
                "ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ê³ ê°ì„¼í„°ì— ë¬¸ì˜í•´ ì£¼ì„¸ìš”"
            ]
        }
        
        return suggestions.get(error_type, ["ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”"])
    
    def _log_error(self, error_info: Dict[str, Any]):
        """ì—ëŸ¬ ë¡œê¹…"""
        logger.error(
            f"Error occurred: {error_info['type']} - {error_info['message']} "
            f"(Session: {error_info['session_id']}, Context: {error_info['context']})"
        )
        
        # ì—ëŸ¬ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
        self.error_history.append(error_info)
        
        # ìµœê·¼ 100ê°œë§Œ ìœ ì§€
        if len(self.error_history) > 100:
            self.error_history = self.error_history[-100:]
    
    def _update_error_stats(self, error_type: ErrorType):
        """ì—ëŸ¬ í†µê³„ ì—…ë°ì´íŠ¸"""
        if error_type.value not in self.error_counts:
            self.error_counts[error_type.value] = 0
        self.error_counts[error_type.value] += 1
    
    def get_error_stats(self) -> Dict[str, Any]:
        """ì—ëŸ¬ í†µê³„ ì¡°íšŒ"""
        return {
            "error_counts": self.error_counts,
            "total_errors": sum(self.error_counts.values()),
            "recent_errors": len([
                e for e in self.error_history 
                if (datetime.now() - e["timestamp"]).total_seconds() < 3600
            ])
        }
```

### 6.4 ë¼ìš°í„° ì—…ë°ì´íŠ¸

#### ì±„íŒ… ë¼ìš°í„° ì—…ë°ì´íŠ¸ (`src/api/routers/chat.py`)
```python
from fastapi import APIRouter, HTTPException, File, UploadFile, Form, Depends
from fastapi.responses import StreamingResponse
from typing import Optional
import uuid
import logging

from ..models.chat import ChatRequest
from ..services.streaming import StreamingService
from ..services.session_manager import SessionManager
from ..services.error_handler import ErrorHandler

logger = logging.getLogger(__name__)
router = APIRouter()

# ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
streaming_service = StreamingService()
session_manager = SessionManager()
error_handler = ErrorHandler()

@router.post("/chat")
async def chat_stream(request: ChatRequest):
    """í…ìŠ¤íŠ¸ ì±„íŒ… ìŠ¤íŠ¸ë¦¬ë° ì—”ë“œí¬ì¸íŠ¸"""
    try:
        # ì„¸ì…˜ í™•ì¸ ë° ìƒì„±
        session = session_manager.get_session(request.session_id)
        if not session:
            session_manager.create_session()
        
        # ë©”ì‹œì§€ë¥¼ ì„¸ì…˜ì— ì¶”ê°€
        session_manager.add_message_to_session(request.session_id, {
            "role": "user",
            "content": request.message,
            "timestamp": datetime.now()
        })
        
        return StreamingResponse(
            streaming_service.stream_chat_response(
                message=request.message,
                session_id=request.session_id
            ),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Access-Control-Allow-Origin": "*",
                "X-Session-ID": request.session_id
            }
        )
    
    except Exception as e:
        logger.error(f"ì±„íŒ… ìŠ¤íŠ¸ë¦¬ë° ì˜¤ë¥˜: {str(e)}")
        error_response = error_handler.handle_error(
            e, 
            {"endpoint": "chat", "message": request.message},
            request.session_id
        )
        raise HTTPException(status_code=500, detail=error_response)

@router.post("/chat/image")
async def chat_image_stream(
    message: str = Form(...),
    session_id: str = Form(...),
    image: UploadFile = File(...)
):
    """ì´ë¯¸ì§€ ì±„íŒ… ìŠ¤íŠ¸ë¦¬ë° ì—”ë“œí¬ì¸íŠ¸"""
    try:
        # ì´ë¯¸ì§€ íŒŒì¼ ê²€ì¦
        if not image.content_type.startswith('image/'):
            raise HTTPException(status_code=400, detail="ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
        
        # íŒŒì¼ í¬ê¸° ì œí•œ (10MB)
        if image.size > 10 * 1024 * 1024:
            raise HTTPException(status_code=400, detail="ì´ë¯¸ì§€ íŒŒì¼ í¬ê¸°ëŠ” 10MB ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")
        
        # ì´ë¯¸ì§€ ë°ì´í„° ì½ê¸°
        image_data = await image.read()
        
        # ì„¸ì…˜ì— ì´ë¯¸ì§€ ë©”ì‹œì§€ ì¶”ê°€
        session_manager.add_message_to_session(session_id, {
            "role": "user",
            "content": message,
            "image": True,
            "timestamp": datetime.now()
        })
        
        return StreamingResponse(
            streaming_service.stream_image_response(
                image_data=image_data,
                message=message,
                session_id=session_id
            ),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Access-Control-Allow-Origin": "*",
                "X-Session-ID": session_id
            }
        )
    
    except Exception as e:
        logger.error(f"ì´ë¯¸ì§€ ì±„íŒ… ìŠ¤íŠ¸ë¦¬ë° ì˜¤ë¥˜: {str(e)}")
        error_response = error_handler.handle_error(
            e,
            {"endpoint": "chat/image", "message": message},
            session_id
        )
        raise HTTPException(status_code=500, detail=error_response)

@router.get("/chat/session")
async def create_session():
    """ìƒˆ ì±„íŒ… ì„¸ì…˜ ìƒì„±"""
    try:
        session_id = session_manager.create_session()
        return {
            "session_id": session_id,
            "created_at": datetime.now().isoformat(),
            "status": "active"
        }
    except Exception as e:
        logger.error(f"ì„¸ì…˜ ìƒì„± ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail="ì„¸ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")

@router.get("/chat/session/{session_id}")
async def get_session_info(session_id: str):
    """ì„¸ì…˜ ì •ë³´ ì¡°íšŒ"""
    try:
        session = session_manager.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
        return {
            "session_id": session_id,
            "created_at": session["created_at"].isoformat(),
            "last_activity": session["last_activity"].isoformat(),
            "message_count": session["message_count"],
            "status": session["status"]
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì„¸ì…˜ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail="ì„¸ì…˜ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")

@router.delete("/chat/session/{session_id}")
async def delete_session(session_id: str):
    """ì„¸ì…˜ ì‚­ì œ"""
    try:
        success = session_manager.delete_session(session_id)
        if not success:
            raise HTTPException(status_code=404, detail="ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
        return {"message": "ì„¸ì…˜ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.", "session_id": session_id}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì„¸ì…˜ ì‚­ì œ ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail="ì„¸ì…˜ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")

@router.get("/chat/sessions/stats")
async def get_session_stats():
    """ì„¸ì…˜ í†µê³„ ì¡°íšŒ"""
    try:
        stats = session_manager.get_session_stats()
        error_stats = error_handler.get_error_stats()
        
        return {
            "session_stats": stats,
            "error_stats": error_stats,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"í†µê³„ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail="í†µê³„ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
```

### 6.5 í…ŒìŠ¤íŠ¸ ì½”ë“œ

#### ìŠ¤íŠ¸ë¦¬ë° í…ŒìŠ¤íŠ¸ (`tests/test_api/test_streaming_advanced.py`)
```python
import pytest
import asyncio
import json
from fastapi.testclient import TestClient
from src.api.main import app
from src.api.services.streaming import StreamingService
from src.api.services.session_manager import SessionManager

client = TestClient(app)

@pytest.fixture
def streaming_service():
    return StreamingService()

@pytest.fixture
def session_manager():
    return SessionManager()

def test_create_session():
    """ì„¸ì…˜ ìƒì„± í…ŒìŠ¤íŠ¸"""
    response = client.get("/api/v1/chat/session")
    assert response.status_code == 200
    data = response.json()
    assert "session_id" in data
    assert "created_at" in data
    assert data["status"] == "active"

def test_get_session_info():
    """ì„¸ì…˜ ì •ë³´ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
    # ì„¸ì…˜ ìƒì„±
    create_response = client.get("/api/v1/chat/session")
    session_id = create_response.json()["session_id"]
    
    # ì„¸ì…˜ ì •ë³´ ì¡°íšŒ
    response = client.get(f"/api/v1/chat/session/{session_id}")
    assert response.status_code == 200
    data = response.json()
    assert data["session_id"] == session_id
    assert "message_count" in data

def test_delete_session():
    """ì„¸ì…˜ ì‚­ì œ í…ŒìŠ¤íŠ¸"""
    # ì„¸ì…˜ ìƒì„±
    create_response = client.get("/api/v1/chat/session")
    session_id = create_response.json()["session_id"]
    
    # ì„¸ì…˜ ì‚­ì œ
    response = client.delete(f"/api/v1/chat/session/{session_id}")
    assert response.status_code == 200
    
    # ì‚­ì œëœ ì„¸ì…˜ ì¡°íšŒ ì‹œ 404
    response = client.get(f"/api/v1/chat/session/{session_id}")
    assert response.status_code == 404

def test_chat_stream_with_session():
    """ì„¸ì…˜ì„ í¬í•¨í•œ ì±„íŒ… ìŠ¤íŠ¸ë¦¬ë° í…ŒìŠ¤íŠ¸"""
    # ì„¸ì…˜ ìƒì„±
    create_response = client.get("/api/v1/chat/session")
    session_id = create_response.json()["session_id"]
    
    # ì±„íŒ… ìŠ¤íŠ¸ë¦¬ë°
    response = client.post(
        "/api/v1/chat",
        json={
            "message": "ì•„ì´í° 15 ìµœì €ê°€",
            "session_id": session_id
        }
    )
    assert response.status_code == 200
    assert response.headers["content-type"] == "text/event-stream; charset=utf-8"
    assert response.headers["x-session-id"] == session_id

@pytest.mark.asyncio
async def test_streaming_service_events(streaming_service):
    """ìŠ¤íŠ¸ë¦¬ë° ì„œë¹„ìŠ¤ ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸"""
    session_id = "test-session"
    message = "í…ŒìŠ¤íŠ¸ ìƒí’ˆ ê²€ìƒ‰"
    
    events = []
    async for event_data in streaming_service.stream_chat_response(message, session_id):
        # SSE í˜•ì‹ íŒŒì‹±
        if event_data.startswith("data: "):
            event_json = json.loads(event_data[6:])
            events.append(event_json)
    
    # ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸
    event_types = [event["type"] for event in events]
    expected_types = ["start", "analysis", "search_start", "complete"]
    
    for expected_type in expected_types:
        assert expected_type in event_types

def test_session_manager_functionality(session_manager):
    """ì„¸ì…˜ ë§¤ë‹ˆì € ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸"""
    # ì„¸ì…˜ ìƒì„±
    session_id = session_manager.create_session()
    assert session_id is not None
    
    # ì„¸ì…˜ ì¡°íšŒ
    session = session_manager.get_session(session_id)
    assert session is not None
    assert session["id"] == session_id
    
    # ë©”ì‹œì§€ ì¶”ê°€
    success = session_manager.add_message_to_session(session_id, {
        "role": "user",
        "content": "í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€"
    })
    assert success is True
    
    # ì„¸ì…˜ ì‚­ì œ
    success = session_manager.delete_session(session_id)
    assert success is True
    
    # ì‚­ì œëœ ì„¸ì…˜ ì¡°íšŒ
    session = session_manager.get_session(session_id)
    assert session is None

def test_error_handling():
    """ì—ëŸ¬ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
    # ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì„¸ì…˜ìœ¼ë¡œ ìš”ì²­
    response = client.get("/api/v1/chat/session/invalid-session-id")
    assert response.status_code == 404
    
    # ì˜ëª»ëœ í˜•ì‹ì˜ ìš”ì²­
    response = client.post("/api/v1/chat", json={})
    assert response.status_code == 422  # Validation error

def test_session_stats():
    """ì„¸ì…˜ í†µê³„ í…ŒìŠ¤íŠ¸"""
    response = client.get("/api/v1/chat/sessions/stats")
    assert response.status_code == 200
    data = response.json()
    assert "session_stats" in data
    assert "error_stats" in data
```

## âœ… ì™„ë£Œ ê¸°ì¤€
- [ ] ê³ ê¸‰ ìŠ¤íŠ¸ë¦¬ë° ì„œë¹„ìŠ¤ êµ¬í˜„ (ë‹¨ê³„ë³„ ì§„í–‰ ìƒí™©)
- [ ] ì„¸ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] Server-Sent Events ì™„ì „ êµ¬í˜„
- [ ] ì‹¤ì‹œê°„ ê²€ìƒ‰ ì§„í–‰ ìƒí™© ì „ì†¡
- [ ] ì„¸ì…˜ ìƒì„±/ì¡°íšŒ/ì‚­ì œ API êµ¬í˜„
- [ ] ì—ëŸ¬ ìŠ¤íŠ¸ë¦¬ë° ë° ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€
- [ ] ì„¸ì…˜ í†µê³„ ë° ëª¨ë‹ˆí„°ë§
- [ ] ìë™ ì„¸ì…˜ ì •ë¦¬ ê¸°ëŠ¥
- [ ] í¬ê´„ì ì¸ í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±

## ğŸ§ª í…ŒìŠ¤íŠ¸ ë°©ë²•

### 1. ìŠ¤íŠ¸ë¦¬ë° API í…ŒìŠ¤íŠ¸
```bash
# ì„œë²„ ì‹¤í–‰
python scripts/run_api.py

# ì„¸ì…˜ ìƒì„±
curl http://localhost:8000/api/v1/chat/session

# ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… í…ŒìŠ¤íŠ¸
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "ì•„ì´í° 15 ìµœì €ê°€", "session_id": "your-session-id"}'
```

### 2. ì„¸ì…˜ ê´€ë¦¬ í…ŒìŠ¤íŠ¸
```bash
# ì„¸ì…˜ ì •ë³´ ì¡°íšŒ
curl http://localhost:8000/api/v1/chat/session/{session_id}

# ì„¸ì…˜ í†µê³„ ì¡°íšŒ
curl http://localhost:8000/api/v1/chat/sessions/stats

# ì„¸ì…˜ ì‚­ì œ
curl -X DELETE http://localhost:8000/api/v1/chat/session/{session_id}
```

### 3. ìë™ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
```bash
pytest tests/test_api/test_streaming_advanced.py -v
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„
[Phase 2 Step 7 - ì´ë¯¸ì§€ ê²€ìƒ‰ ê¸°ëŠ¥ êµ¬í˜„](mdc:.cursor/rules/tasks/phase2-step7-image-search.mdc)

## ğŸ“š ì°¸ê³  ë¬¸ì„œ
- [ê°œë°œ íƒœìŠ¤í¬ ê³„íš](mdc:.cursor/rules/development-task-plan.mdc)
- [API ëª…ì„¸ì„œ](mdc:.cursor/rules/api-specification.mdc)
- [ê¸°ìˆ  ì•„í‚¤í…ì²˜](mdc:.cursor/rules/technical-architecture.mdc)

